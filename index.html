<!DOCTYPE html>
<html>

<head>
  <title>Subsonic Webui</title>
  <!-- MD5 implementation, because js doesn't have a builtin for it -->
  <!-- Alternative would be to rely on plain password, the OSS POST extension or the OSS API key extension. -->
  <script src="https://pajhome.org.uk/crypt/md5/md5.js"></script>
  <script>
    class SubsonicHandler {
      /**
      * @param {string} server
      * @param {string} username
      * @param {string} password
      */
      constructor(server, username, password) {
        this.username = username;
        this.server = server;
        this.password = password;
      }

      /**
      * @param {string} view
      * @param {URLSearchParams} params
      */
      build_request(view, params) {
        // see https://opensubsonic.netlify.app/docs/api-reference/
        params.append("u", this.username);
        params.append("v", "1.16.0");
        params.append("c", "subsonic-webui");
        params.append("f", "json");

        // ideally would use the crypto lib for both md5 and salt gen.
        // Why didn't I just do that? Spite and sunk cost. Mostly spite.
        let salt = "";
        for (let i = 0; i < 4; i++) {
          let rand = Math.floor(Math.random() * 255).toString(16).padStart(2, '0');
          salt = salt + rand;
        }

        let token = hex_md5(`${this.password}${salt}`);
        params.append("t", token);
        params.append("s", salt);

        return `${this.server}/rest/${view}?${params}`;
      }

      /**
      * @param {string} view
      * @param {URLSearchParams} params
      */
      async json_request(view, params) {
        let resp = (await (await fetch(this.build_request(view, params))).json())["subsonic-response"];
        if (resp.status != "ok") {
          throw new Error(resp.error.message);
        }
        return resp;
      }
    }

    class Browser {
      /**
      * @param {SubsonicHandler} client
      * @param {Player} player
      */
      constructor(client, player) {
        this.client = client;
        this.player = player;
        this.dir_listing = document.querySelector("ul#curr-dir");
        this.nav_chain = [];

        this.populate_dir(null);
      }

      /**
      * @param {string | null} dir_id
      */
      async populate_dir(dir_id) {
        let dirs = {};
        let songs = {};
        try {
          // dir_id is either an id or null. Null indicates root, which doesn't have an ID with defined value across servers.
          // getIndexes returns both "childs" and "indexes", essentially files and folders,
          // get getMusicDirectory only returns "childs", which may be either files or folders.
          // confused? good.
          let children; // list of "child" objects.
          if (dir_id) {
            let resp = await this.client.json_request("getMusicDirectory", new URLSearchParams({id: dir_id}));
            console.log(resp);
            children = resp.directory.child;
          } else {
            let resp = await this.client.json_request("getIndexes", new URLSearchParams());
            console.log(resp);
            for (let index of resp.indexes.index) {
              for (let dir of index.artist) {
                dirs[dir.id] = dir.name;
              }
            }
            children = resp.indexes.child;
          }

          if (children) {
            for (let child of children) {
              if (child.isDir) {
                dirs[child.id] = child.title;
              } else {
                songs[child.id] = child.title;
              }
            }
          }

        } catch (err) {
          console.error(err);
          window.setTimeout(this.populate_dir, 5000, dir_id); // if something fails, try again. Only problem in active use should be networking, which nothing to do but test
          return;
        }

        // part 2, add buttons for navigation
        let entries = [];
        if (this.nav_chain.length > 0) {
          entries.push(this.make_link(null, ".."));
        }
        for (let [id, name] of Object.entries(dirs)) {
          entries.push(this.make_link(id, name));
        }

        for (let [id, name] of Object.entries(songs)) {
          entries.push(this.make_play(id, name));
        }

        this.dir_listing.replaceChildren(...entries);
      }

      /**
      * @param {string | null} dir_id
      * @param {string} text
      */
      make_link(dir_id, text) {
        let el = document.createElement("li");
        el.classList.add("dir");
        let button = document.createElement("button");
        button.type = "button";
        button.innerText = text;
        button.addEventListener("click", () => {
          if (dir_id) {
            this.populate_dir(dir_id);
            this.nav_chain.push(dir_id);
          } else {
            this.populate_dir(this.nav_chain.length > 1 ? this.nav_chain[this.nav_chain.length - 2] : null);
            this.nav_chain.pop();
          }
        });
        el.replaceChildren(button);
        return el;
      }

      /**
      * @param {string | null} song_id
      * @param {string} text
      */
      make_play(song_id, text) {
        let el = document.createElement("li");
        el.classList.add("song");
        let button = document.createElement("button");
        button.type = "button";
        button.innerText = text;

        button.addEventListener("click", () => {
          this.player.play(song_id);
        });

        el.replaceChildren(button);
        return el;
      }

      reset() {
        this.nav_chain = [];
        this.populate_dir(null);
      }
    }

    class Player {
      /**
      * @param {SubsonicHandler} client
      */
      constructor(client) {
        this.client = client;
        this.player_section = document.querySelector("aside");
      }

      /**
      * @param {string} song_id
      */
      async play(song_id) {
        try {
          let metadata = await this.client.json_request("getSong", new URLSearchParams({id: song_id}));
          this.player_section.querySelector("h2#aside-title").innerText = metadata.song.title;
          this.player_section.querySelector("h4#aside-album").innerText = metadata.song.album;
          // for later reuse. Since this has auth creds, not a good idea for anything beyond a toy project
          let artwork = this.client.build_request("getCoverArt", new URLSearchParams({id: metadata.song.coverArt}));
          this.player_section.querySelector("img#aside-cover").setAttribute("src", artwork);
          this.player_section.querySelector("audio#aside-audio").setAttribute("src", this.client.build_request("stream", new URLSearchParams({id: metadata.song.id})));

          if ("mediaSession" in navigator) {
            navigator.mediaSession.metadata = new MediaMetadata({
              title: metadata.song.title,
              album: metadata.song.album,
              artwork: [{src: artwork}],
            })
          }
        } catch (err) {
          window.setInterval(this.play, 5000, song_id);
        }
      }
    }

    document.addEventListener("DOMContentLoaded", () => {
      const dialog = document.querySelector("dialog");
      const err_msg = document.querySelector("form #error");
      dialog.showModal();

      let browser;

      document.querySelector("form#auth").addEventListener("submit", async (ev) => {
        let creds = new FormData(ev.target);
        let subsonic_handler = new SubsonicHandler(creds.get("server"), creds.get("name"), creds.get("password"));
        try {
          let resp = await subsonic_handler.json_request("ping", new URLSearchParams());
          err_msg.innerText = "";
          let player = new Player(subsonic_handler);
          browser = new Browser(subsonic_handler, player);
        } catch (err) {
          document.querySelector("form #error").innerText = err.toString();
          // in about every conceivable network setup (maybe besides having the server on the same machine and requesting over loopback)
          // the modal should close from submission before the response comes back.
          // a better solution would simply be to preventDefault, but I am lazy.
          dialog.showModal();
        }
      });

      document.querySelector("main button#dir-reset").addEventListener("click", () => {
        browser.reset();
      });
    });
  </script>


</head>

<body>
  <!-- Dialog shown on load. Credentials API isn't standard yet across browsers, what can you do -->
  <dialog>
    <form id="auth" method="dialog">
      <h1>Subsonic Login</h1>
      <label for="auth-server">Server: </label>
      <input id="auth-server" name="server" type="url" placeholder="https://demo.navidrome.org" required />

      <label for="auth-name">Username: </label>
      <input id="auth-name" name="name" type="text" placeholder="demo" required />

      <label for="auth-pass">Password: </label>
      <input id="auth-pass" name="password" type="password" placeholder="demo" required />

      <button type="submit">Login</button>

      <p id="error"></p>
    </form>
  </dialog>

  <!-- Main holds directory nav. Button to return to root for convenience. Will follow the same conventions as github/forgejo having ".." to go up one dir. -->
  <main>
    <button id="dir-reset" type="submit">Root</button>
    <ul id="curr-dir">
    </ul>
  </main>

  <!-- Aside holds metadata about the playing song and the actual audio element. Side drawer on landscape, bottom drawer on portrait -->
  <aside>
    <h2 id="aside-title"></h2>
    <h4 id="aside-album"></h4>
    <img src="about:blank" id="aside-cover" />
    <audio controls src="about:blank" id="aside-audio"></audio>
  </aside>
</body>

</html>